# 01. 左值右值

## <font color=cyan>01. 定义</font>

|         |        |                                          |                                                              |
| ------- | :----- | :--------------------------------------- | :----------------------------------------------------------- |
| lvalue  | 左值   | 有可访问的内存地址                       | 变量名，const变量，数组元素，返回左值引用的函数调用，类成员  |
| prvalue | 纯右值 | 没有可访问的内存地址                     | 字面值常量，返回非引用类型的函数调用，在表达式求值期间创建但是只能被编译器访问的临时对象 |
| xvalue  | 将亡值 | 有地址但不会再被访问，可以初始化右值引用 | 返回右值引用的函数调用，数组下标                             |

## <font color=cyan>02. 函数模板实例化</font>

> *If you have several identical instantiations, even in different modules, only one copy of the instantiation will end up in the executable file.*

## <font color=cyan>03. 使用extern关键字阻止类成员函数自动实例化</font>

```c++

```

> <font color=red>显示实例化有什么用？</font>

## <font color=cyan>04. 函数模板特化</font>

```c++

```

> <font color=red>模板特化是为了针对特定类型需要实现特殊行为设置的，需要有自己的函数体</font>
>
> <font color=red>模板实例化不需要有自己的函数体，和通用模板行为一致</font>

## <font color=cyan>04. 实例化偏序机制</font>

<font color=yellow>如果在函数调用时，参数列表可以匹配多个函数模版，则选择最特化的那一个: 如果一个模版参数列表有效适配另一个模版，但是反过来不行，那么这个模版就不够特化</font> 

几个常用规则:

* 优先选择显示匹配的模版，忽略隐式转换
* T* 比 T 更特化
* const T 比 T 更特化
* const T* 比 T* 更特化

```c++
template <typename T>
void fun(T a)
{
    std::cout << "T" << std::endl;
}

template <typename T>
void fun(const T a)
{
    std::cout << "const T" << std::endl;
}
```

```shell
error: redefinition of 'fun'
```



